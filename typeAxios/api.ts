/* tslint:disable */
/* eslint-disable */
/**
 * netuserapi
 * This api is used for the management of users created for the netelek web apps
 *
 * The version of the OpenAPI document: 1.0.10
 * Contact: devsupport@remig.co.za
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AccessRequest
 */
export interface AccessRequest {
    /**
     * 
     * @type {number}
     * @memberof AccessRequest
     */
    'requestId'?: number;
    /**
     * 
     * @type {string}
     * @memberof AccessRequest
     */
    'userName'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccessRequest
     */
    'path'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccessRequest
     */
    'httpMethod'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccessRequest
     */
    'className'?: string;
}
/**
 * 
 * @export
 * @interface AssignedGroupIdsForUserId
 */
export interface AssignedGroupIdsForUserId {
    /**
     * 
     * @type {number}
     * @memberof AssignedGroupIdsForUserId
     */
    'userId'?: number;
    /**
     * 
     * @type {string}
     * @memberof AssignedGroupIdsForUserId
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof AssignedGroupIdsForUserId
     */
    'password'?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof AssignedGroupIdsForUserId
     */
    'assignedGroupIds'?: Array<number>;
}
/**
 * 
 * @export
 * @interface AssignedMethodIdsForGroupId
 */
export interface AssignedMethodIdsForGroupId {
    /**
     * 
     * @type {number}
     * @memberof AssignedMethodIdsForGroupId
     */
    'groupId'?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof AssignedMethodIdsForGroupId
     */
    'assignedMethodIds'?: Array<number>;
}
/**
 * 
 * @export
 * @interface AssignedMethodIdsForUserId
 */
export interface AssignedMethodIdsForUserId {
    /**
     * 
     * @type {number}
     * @memberof AssignedMethodIdsForUserId
     */
    'userId'?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof AssignedMethodIdsForUserId
     */
    'assignedMethodIds'?: Array<number>;
}
/**
 * 
 * @export
 * @interface AssignedUserIdsForGroupId
 */
export interface AssignedUserIdsForGroupId {
    /**
     * 
     * @type {number}
     * @memberof AssignedUserIdsForGroupId
     */
    'groupId'?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof AssignedUserIdsForGroupId
     */
    'assignedUserIds'?: Array<number>;
}
/**
 * 
 * @export
 * @interface BulkSMS
 */
export interface BulkSMS {
    /**
     * 
     * @type {Array<string>}
     * @memberof BulkSMS
     */
    'numbers'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof BulkSMS
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface ChangePasswordRequest
 */
export interface ChangePasswordRequest {
    /**
     * 
     * @type {string}
     * @memberof ChangePasswordRequest
     */
    'newPassword'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChangePasswordRequest
     */
    'userName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChangePasswordRequest
     */
    'oldPassword'?: string;
}
/**
 * 
 * @export
 * @interface Clock
 */
export interface Clock {
    /**
     * 
     * @type {number}
     * @memberof Clock
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof Clock
     */
    'netUserId'?: number;
    /**
     * 
     * @type {number}
     * @memberof Clock
     */
    'latitudeIn'?: number;
    /**
     * 
     * @type {number}
     * @memberof Clock
     */
    'longitudeIn'?: number;
    /**
     * 
     * @type {number}
     * @memberof Clock
     */
    'latitudeOut'?: number;
    /**
     * 
     * @type {number}
     * @memberof Clock
     */
    'longitudeOut'?: number;
    /**
     * 
     * @type {string}
     * @memberof Clock
     */
    'inDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof Clock
     */
    'outDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof Clock
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface HttpCall
 */
export interface HttpCall {
    /**
     * 
     * @type {string}
     * @memberof HttpCall
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof HttpCall
     */
    'method'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof HttpCall
     */
    'allowed'?: boolean;
}
/**
 * 
 * @export
 * @interface MethodAuthCheck
 */
export interface MethodAuthCheck {
    /**
     * 
     * @type {string}
     * @memberof MethodAuthCheck
     */
    'httpMethod'?: string;
    /**
     * 
     * @type {string}
     * @memberof MethodAuthCheck
     */
    'httpPath'?: string;
    /**
     * 
     * @type {string}
     * @memberof MethodAuthCheck
     */
    'className'?: string;
    /**
     * 
     * @type {string}
     * @memberof MethodAuthCheck
     */
    'projectName'?: string;
}
/**
 * 
 * @export
 * @interface Methods
 */
export interface Methods {
    /**
     * 
     * @type {number}
     * @memberof Methods
     */
    'methodId'?: number;
    /**
     * 
     * @type {string}
     * @memberof Methods
     */
    'projectName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Methods
     */
    'packageName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Methods
     */
    'className'?: string;
    /**
     * 
     * @type {string}
     * @memberof Methods
     */
    'methodName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Methods
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Methods
     */
    'desciption'?: string;
}
/**
 * 
 * @export
 * @interface RetailStaffShifts
 */
export interface RetailStaffShifts {
    /**
     * 
     * @type {number}
     * @memberof RetailStaffShifts
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof RetailStaffShifts
     */
    'shiftId'?: number;
    /**
     * 
     * @type {number}
     * @memberof RetailStaffShifts
     */
    'userId'?: number;
    /**
     * 
     * @type {string}
     * @memberof RetailStaffShifts
     */
    'validDate'?: string;
    /**
     * 
     * @type {number}
     * @memberof RetailStaffShifts
     */
    'startMinute'?: number;
    /**
     * 
     * @type {number}
     * @memberof RetailStaffShifts
     */
    'startHour'?: number;
    /**
     * 
     * @type {number}
     * @memberof RetailStaffShifts
     */
    'endMinute'?: number;
    /**
     * 
     * @type {number}
     * @memberof RetailStaffShifts
     */
    'endHour'?: number;
    /**
     * 
     * @type {string}
     * @memberof RetailStaffShifts
     */
    'timezone'?: string;
    /**
     * 
     * @type {number}
     * @memberof RetailStaffShifts
     */
    'storeId'?: number;
}
/**
 * 
 * @export
 * @interface Shifts
 */
export interface Shifts {
    /**
     * 
     * @type {number}
     * @memberof Shifts
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof Shifts
     */
    'storeId'?: number;
    /**
     * 
     * @type {number}
     * @memberof Shifts
     */
    'startMinute'?: number;
    /**
     * 
     * @type {number}
     * @memberof Shifts
     */
    'startHour'?: number;
    /**
     * 
     * @type {number}
     * @memberof Shifts
     */
    'endMinute'?: number;
    /**
     * 
     * @type {number}
     * @memberof Shifts
     */
    'endHour'?: number;
    /**
     * 
     * @type {string}
     * @memberof Shifts
     */
    'validFrom'?: string;
    /**
     * 
     * @type {string}
     * @memberof Shifts
     */
    'validTo'?: string;
    /**
     * 
     * @type {string}
     * @memberof Shifts
     */
    'assignedDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof Shifts
     */
    'timezone'?: string;
    /**
     * 
     * @type {string}
     * @memberof Shifts
     */
    'validDays'?: string;
}
/**
 * 
 * @export
 * @interface StringList
 */
export interface StringList {
    /**
     * 
     * @type {Array<string>}
     * @memberof StringList
     */
    'stringList'?: Array<string>;
}
/**
 * 
 * @export
 * @interface Task
 */
export interface Task {
    /**
     * 
     * @type {number}
     * @memberof Task
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof Task
     */
    'datetime'?: number;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'project'?: string;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'area'?: string;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof Task
     */
    'netdeskJobRef'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Task
     */
    'sleepOut'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Task
     */
    'otherMethodOfTransport'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Task
     */
    'kmTraveled'?: number;
    /**
     * 
     * @type {number}
     * @memberof Task
     */
    'travelTime'?: number;
    /**
     * 
     * @type {number}
     * @memberof Task
     */
    'workHours'?: number;
    /**
     * 
     * @type {number}
     * @memberof Task
     */
    'timeTypeId'?: number;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'timestamp'?: string;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'user'?: string;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'approvedUser'?: string;
    /**
     * 
     * @type {number}
     * @memberof Task
     */
    'approvedDate'?: number;
    /**
     * 
     * @type {number}
     * @memberof Task
     */
    'latitude'?: number;
    /**
     * 
     * @type {number}
     * @memberof Task
     */
    'longitude'?: number;
    /**
     * 
     * @type {number}
     * @memberof Task
     */
    'latitudeOut'?: number;
    /**
     * 
     * @type {number}
     * @memberof Task
     */
    'longitudeOut'?: number;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'inDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'outDate'?: string;
}
/**
 * 
 * @export
 * @interface TaskRef
 */
export interface TaskRef {
    /**
     * 
     * @type {Array<number>}
     * @memberof TaskRef
     */
    'idList'?: Array<number>;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'userName'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'password'?: string;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'passwordExpires'?: number;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'userId'?: number;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'fullname'?: string;
}
/**
 * 
 * @export
 * @interface UserGroupIdList
 */
export interface UserGroupIdList {
    /**
     * 
     * @type {Array<number>}
     * @memberof UserGroupIdList
     */
    'userGroupIdList'?: Array<number>;
}
/**
 * 
 * @export
 * @interface UserGroups
 */
export interface UserGroups {
    /**
     * 
     * @type {number}
     * @memberof UserGroups
     */
    'groupId'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserGroups
     */
    'groupName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserGroups
     */
    'description'?: string;
    /**
     * 
     * @type {Array<Methods>}
     * @memberof UserGroups
     */
    'methodsList'?: Array<Methods>;
    /**
     * 
     * @type {Array<Users>}
     * @memberof UserGroups
     */
    'usersList'?: Array<Users>;
    /**
     * 
     * @type {number}
     * @memberof UserGroups
     */
    'dateCreated'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof UserGroups
     */
    'isUser'?: boolean;
}
/**
 * 
 * @export
 * @interface UserHttpCalls
 */
export interface UserHttpCalls {
    /**
     * 
     * @type {string}
     * @memberof UserHttpCalls
     */
    'user'?: string;
    /**
     * 
     * @type {Array<HttpCall>}
     * @memberof UserHttpCalls
     */
    'httpCalls'?: Array<HttpCall>;
}
/**
 * 
 * @export
 * @interface UserIdList
 */
export interface UserIdList {
    /**
     * 
     * @type {Array<number>}
     * @memberof UserIdList
     */
    'userIdList'?: Array<number>;
}
/**
 * 
 * @export
 * @interface UserInfo
 */
export interface UserInfo {
    /**
     * 
     * @type {number}
     * @memberof UserInfo
     */
    'userId'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserInfo
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserInfo
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserInfo
     */
    'fullname'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserInfo
     */
    'password'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserInfo
     */
    'userGroupList'?: Array<string>;
}
/**
 * 
 * @export
 * @interface UserList
 */
export interface UserList {
    /**
     * 
     * @type {Array<Users>}
     * @memberof UserList
     */
    'usersList'?: Array<Users>;
}
/**
 * 
 * @export
 * @interface UserSetting
 */
export interface UserSetting {
    /**
     * 
     * @type {number}
     * @memberof UserSetting
     */
    'userSettingId'?: number;
    /**
     * 
     * @type {number}
     * @memberof UserSetting
     */
    'settingId'?: number;
    /**
     * 
     * @type {number}
     * @memberof UserSetting
     */
    'userId'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserSetting
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface Users
 */
export interface Users {
    /**
     * 
     * @type {number}
     * @memberof Users
     */
    'userid'?: number;
    /**
     * 
     * @type {string}
     * @memberof Users
     */
    'userName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Users
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof Users
     */
    'contactNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof Users
     */
    'email'?: string;
    /**
     * 
     * @type {number}
     * @memberof Users
     */
    'passwordExpires'?: number;
    /**
     * 
     * @type {number}
     * @memberof Users
     */
    'dateCreated'?: number;
    /**
     * 
     * @type {string}
     * @memberof Users
     */
    'fullName'?: string;
    /**
     * 
     * @type {number}
     * @memberof Users
     */
    'parentUserId'?: number;
    /**
     * 
     * @type {string}
     * @memberof Users
     */
    'employeeNumber'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Users
     */
    'profilePicture'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof Users
     */
    'hasChildren'?: number;
    /**
     * 
     * @type {string}
     * @memberof Users
     */
    'userTitle'?: string;
    /**
     * 
     * @type {string}
     * @memberof Users
     */
    'employerCompany'?: string;
    /**
     * 
     * @type {string}
     * @memberof Users
     */
    'userDepartment'?: string;
    /**
     * 
     * @type {string}
     * @memberof Users
     */
    'orgChartCompany'?: string;
}
/**
 * 
 * @export
 * @interface WhatsappIncommingObj
 */
export interface WhatsappIncommingObj {
    /**
     * 
     * @type {string}
     * @memberof WhatsappIncommingObj
     */
    'json'?: string;
    /**
     * 
     * @type {WhatsappMessage}
     * @memberof WhatsappIncommingObj
     */
    'whatsappMessage'?: WhatsappMessage;
}
/**
 * 
 * @export
 * @interface WhatsappMessage
 */
export interface WhatsappMessage {
    /**
     * 
     * @type {number}
     * @memberof WhatsappMessage
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof WhatsappMessage
     */
    'contact'?: number;
    /**
     * 
     * @type {string}
     * @memberof WhatsappMessage
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof WhatsappMessage
     */
    'timestamp'?: string;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {UserGroups} [userGroups] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (userGroups?: UserGroups, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/usergroups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userGroups, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<Shifts>} [shifts] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addNewShiftList: async (shifts?: Array<Shifts>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/shift/newshiftlist`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shifts, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [oldAssignedDate] 
         * @param {Array<Shifts>} [shifts] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addShifts: async (oldAssignedDate?: number, shifts?: Array<Shifts>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/shift`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (oldAssignedDate !== undefined) {
                localVarQueryParameter['oldAssignedDate'] = oldAssignedDate;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shifts, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Clock} [clock] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTimesheetEntry: async (clock?: Clock, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/clock/addTimesheetEntry`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clock, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TaskRef} [taskRef] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveTask: async (taskRef?: TaskRef, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/task/approve`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(taskRef, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} groupid 
         * @param {AssignedMethodIdsForGroupId} [assignedMethodIdsForGroupId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignMethods: async (groupid: number, assignedMethodIdsForGroupId?: AssignedMethodIdsForGroupId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupid' is not null or undefined
            assertParamExists('assignMethods', 'groupid', groupid)
            const localVarPath = `/resources/usergroups/{groupid}/methods`
                .replace(`{${"groupid"}}`, encodeURIComponent(String(groupid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(assignedMethodIdsForGroupId, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} userid 
         * @param {AssignedMethodIdsForUserId} [assignedMethodIdsForUserId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignMethods1: async (userid: number, assignedMethodIdsForUserId?: AssignedMethodIdsForUserId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userid' is not null or undefined
            assertParamExists('assignMethods1', 'userid', userid)
            const localVarPath = `/resources/users/{userid}/usermethods`
                .replace(`{${"userid"}}`, encodeURIComponent(String(userid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(assignedMethodIdsForUserId, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<Shifts>} [shifts] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignShiftListToStores: async (shifts?: Array<Shifts>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/shift/storeshiftlist`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shifts, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Shifts} [shifts] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignShiftToStore: async (shifts?: Shifts, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/shift/assignshifttostore`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shifts, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RetailStaffShifts} [retailStaffShifts] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignToUser: async (retailStaffShifts?: RetailStaffShifts, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/shift/assigntouser`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(retailStaffShifts, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} groupid 
         * @param {AssignedUserIdsForGroupId} [assignedUserIdsForGroupId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignUserAssociation: async (groupid: number, assignedUserIdsForGroupId?: AssignedUserIdsForGroupId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupid' is not null or undefined
            assertParamExists('assignUserAssociation', 'groupid', groupid)
            const localVarPath = `/resources/usergroups/{groupid}/users/association`
                .replace(`{${"groupid"}}`, encodeURIComponent(String(groupid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(assignedUserIdsForGroupId, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} userid 
         * @param {AssignedGroupIdsForUserId} [assignedGroupIdsForUserId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignUserGroups: async (userid: number, assignedGroupIdsForUserId?: AssignedGroupIdsForUserId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userid' is not null or undefined
            assertParamExists('assignUserGroups', 'userid', userid)
            const localVarPath = `/resources/users/{userid}/usergroups`
                .replace(`{${"userid"}}`, encodeURIComponent(String(userid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(assignedGroupIdsForUserId, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} groupid 
         * @param {AssignedUserIdsForGroupId} [assignedUserIdsForGroupId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignUsers: async (groupid: number, assignedUserIdsForGroupId?: AssignedUserIdsForGroupId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupid' is not null or undefined
            assertParamExists('assignUsers', 'groupid', groupid)
            const localVarPath = `/resources/usergroups/{groupid}/users`
                .replace(`{${"groupid"}}`, encodeURIComponent(String(groupid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(assignedUserIdsForGroupId, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {MethodAuthCheck} [methodAuthCheck] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        canRemoteUserDo: async (methodAuthCheck?: MethodAuthCheck, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/remoteauth/canremoteuserdo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(methodAuthCheck, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} userid 
         * @param {string} [password] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword: async (userid: number, password?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userid' is not null or undefined
            assertParamExists('changePassword', 'userid', userid)
            const localVarPath = `/resources/users/{userid}/password`
                .replace(`{${"userid"}}`, encodeURIComponent(String(userid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (password !== undefined) {
                localVarQueryParameter['password'] = password;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UserHttpCalls} [userHttpCalls] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkUserAllowedHttpMethods: async (userHttpCalls?: UserHttpCalls, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/users/allowedhttpmethods`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userHttpCalls, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [userName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearCache: async (userName?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/users/clearcache`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (userName !== undefined) {
                localVarQueryParameter['userName'] = userName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<Clock>} [clock] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clockIn: async (clock?: Array<Clock>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/clock`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clock, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyStructureLists: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/users/companystructurelist`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Methods} [methods] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (methods?: Methods, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/methods`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(methods, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UserGroups} [userGroups] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create1: async (userGroups?: UserGroups, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/usergroups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userGroups, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<Task>} [task] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTask: async (task?: Array<Task>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/task`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(task, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {boolean} [customerportal] 
         * @param {Users} [users] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserFromToken: async (customerportal?: boolean, users?: Users, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (customerportal !== undefined) {
                localVarQueryParameter['customerportal'] = customerportal;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(users, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} settingid 
         * @param {UserSetting} [userSetting] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserSetting: async (settingid: number, userSetting?: UserSetting, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'settingid' is not null or undefined
            assertParamExists('createUserSetting', 'settingid', settingid)
            const localVarPath = `/resources/setting/{settingid}/user`
                .replace(`{${"settingid"}}`, encodeURIComponent(String(settingid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userSetting, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<AccessRequest>} [accessRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createaccessRequest: async (accessRequest?: Array<AccessRequest>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/accessrequest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accessRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [requestId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        declineRequest: async (requestId?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/accessrequest/decline`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (requestId !== undefined) {
                localVarQueryParameter['RequestId'] = requestId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Methods} [methods] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edit: async (methods?: Methods, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/methods`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(methods, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UserGroups} [userGroups] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edit1: async (userGroups?: UserGroups, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/usergroups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userGroups, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Users} [users] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edit2: async (users?: Users, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(users, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} userid 
         * @param {string} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editPassword: async (userid: number, body?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userid' is not null or undefined
            assertParamExists('editPassword', 'userid', userid)
            const localVarPath = `/resources/users/{userid}/password`
                .replace(`{${"userid"}}`, encodeURIComponent(String(userid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<Clock>} [clock] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editTask: async (clock?: Array<Clock>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/clock`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clock, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<Task>} [task] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editTask1: async (task?: Array<Task>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/task`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(task, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventNotification: async (body?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/whatsapp/webhooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {User} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expirePassword: async (user?: User, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/users/expirePassword`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllUserGroups: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/usergroups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [companyid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findBusinessGroupByCompany: async (companyid?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/businessgroup/findBusinessGroupByCompany`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (companyid !== undefined) {
                localVarQueryParameter['companyid'] = companyid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} software 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findBySoftware: async (software: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'software' is not null or undefined
            assertParamExists('findBySoftware', 'software', software)
            const localVarPath = `/resources/setting/software/{software}`
                .replace(`{${"software"}}`, encodeURIComponent(String(software)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} settingid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findByUserAndSettingName: async (settingid: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'settingid' is not null or undefined
            assertParamExists('findByUserAndSettingName', 'settingid', settingid)
            const localVarPath = `/resources/setting/{settingid}/user`
                .replace(`{${"settingid"}}`, encodeURIComponent(String(settingid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} software 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findByUserAndSettingName1: async (software: string, name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'software' is not null or undefined
            assertParamExists('findByUserAndSettingName1', 'software', software)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('findByUserAndSettingName1', 'name', name)
            const localVarPath = `/resources/setting/software/{software}/name/{name}/user`
                .replace(`{${"software"}}`, encodeURIComponent(String(software)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} software 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findByUserAndSoftware: async (software: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'software' is not null or undefined
            assertParamExists('findByUserAndSoftware', 'software', software)
            const localVarPath = `/resources/setting/software/{software}/user`
                .replace(`{${"software"}}`, encodeURIComponent(String(software)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} groupid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findGroup: async (groupid: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupid' is not null or undefined
            assertParamExists('findGroup', 'groupid', groupid)
            const localVarPath = `/resources/usergroups/{groupid}/info`
                .replace(`{${"groupid"}}`, encodeURIComponent(String(groupid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupname 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findGroup1: async (groupname: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupname' is not null or undefined
            assertParamExists('findGroup1', 'groupname', groupname)
            const localVarPath = `/resources/usergroups/{groupname}/find`
                .replace(`{${"groupname"}}`, encodeURIComponent(String(groupname)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [path] 
         * @param {string} [httpmethod] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findMethod: async (path?: string, httpmethod?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/accessrequest/findMethod`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }

            if (httpmethod !== undefined) {
                localVarQueryParameter['httpmethod'] = httpmethod;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [topic] 
         * @param {string} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findMethod1: async (topic?: string, body?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/mqtest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (topic !== undefined) {
                localVarQueryParameter['topic'] = topic;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} methodid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findMethod2: async (methodid: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'methodid' is not null or undefined
            assertParamExists('findMethod2', 'methodid', methodid)
            const localVarPath = `/resources/methods/{methodid}/info`
                .replace(`{${"methodid"}}`, encodeURIComponent(String(methodid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSubUsers: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/users/subusers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSubUsersCascade: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/users/subusers/cascade`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTask: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('findTask', 'id', id)
            const localVarPath = `/resources/task/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [sdate] 
         * @param {number} [edate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTasks: async (sdate?: number, edate?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/task`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (sdate !== undefined) {
                localVarQueryParameter['sdate'] = sdate;
            }

            if (edate !== undefined) {
                localVarQueryParameter['edate'] = edate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve user information by user ID
         * @summary Get user information
         * @param {number} userid User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUser: async (userid: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userid' is not null or undefined
            assertParamExists('findUser', 'userid', userid)
            const localVarPath = `/resources/users/{userid}/info`
                .replace(`{${"userid"}}`, encodeURIComponent(String(userid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUserByUserName: async (username: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('findUserByUserName', 'username', username)
            const localVarPath = `/resources/users/byusername/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UserList} [userList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUserIdsByName: async (userList?: UserList, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/users/useridsbyname`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userList, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} userid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUsersSubUsers: async (userid: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userid' is not null or undefined
            assertParamExists('findUsersSubUsers', 'userid', userid)
            const localVarPath = `/resources/users/{userid}/subusers`
                .replace(`{${"userid"}}`, encodeURIComponent(String(userid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} oauthprovider 
         * @param {string} username 
         * @param {string} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateUserToken: async (oauthprovider: string, username: string, body?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'oauthprovider' is not null or undefined
            assertParamExists('generateUserToken', 'oauthprovider', oauthprovider)
            // verify required parameter 'username' is not null or undefined
            assertParamExists('generateUserToken', 'username', username)
            const localVarPath = `/resources/users/oauth/{oauthprovider}/{username}`
                .replace(`{${"oauthprovider"}}`, encodeURIComponent(String(oauthprovider)))
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccessRequest: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/accessrequest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [netstoreid] 
         * @param {number} [sdate] 
         * @param {number} [edate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveStoreUsers: async (netstoreid?: number, sdate?: number, edate?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/shift/activestoreusers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (netstoreid !== undefined) {
                localVarQueryParameter['netstoreid'] = netstoreid;
            }

            if (sdate !== undefined) {
                localVarQueryParameter['sdate'] = sdate;
            }

            if (edate !== undefined) {
                localVarQueryParameter['edate'] = edate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAppUserGroupsByUser: async (userId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getAppUserGroupsByUser', 'userId', userId)
            const localVarPath = `/resources/usergroups/userApps/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} userid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBranchParent: async (userid: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userid' is not null or undefined
            assertParamExists('getBranchParent', 'userid', userid)
            const localVarPath = `/resources/users/{userid}/branch/parent`
                .replace(`{${"userid"}}`, encodeURIComponent(String(userid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} userid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBranchUsers: async (userid: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userid' is not null or undefined
            assertParamExists('getBranchUsers', 'userid', userid)
            const localVarPath = `/resources/users/{userid}/branch/users`
                .replace(`{${"userid"}}`, encodeURIComponent(String(userid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [path] 
         * @param {number} [pageno] 
         * @param {number} [rows] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEndpointTraffic: async (path?: string, pageno?: number, rows?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/endpoint`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }

            if (pageno !== undefined) {
                localVarQueryParameter['pageno'] = pageno;
            }

            if (rows !== undefined) {
                localVarQueryParameter['rows'] = rows;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [userName] 
         * @param {string} [path] 
         * @param {string} [methodName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupAndUserAccess: async (userName?: string, path?: string, methodName?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/usergroups/accessForbidden`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (userName !== undefined) {
                localVarQueryParameter['userName'] = userName;
            }

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }

            if (methodName !== undefined) {
                localVarQueryParameter['methodName'] = methodName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} groupid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupMethods: async (groupid: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupid' is not null or undefined
            assertParamExists('getGroupMethods', 'groupid', groupid)
            const localVarPath = `/resources/usergroups/{groupid}/methods`
                .replace(`{${"groupid"}}`, encodeURIComponent(String(groupid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} groupid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupnamesAndIds: async (groupid: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupid' is not null or undefined
            assertParamExists('getGroupnamesAndIds', 'groupid', groupid)
            const localVarPath = `/resources/usergroups/{groupid}/groupnamesandids`
                .replace(`{${"groupid"}}`, encodeURIComponent(String(groupid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLocations: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/clock/locations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMainTree: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/users/main/tree`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [path] 
         * @param {boolean} [get] 
         * @param {boolean} [put] 
         * @param {boolean} [post] 
         * @param {boolean} [_delete] 
         * @param {number} [from] 
         * @param {number} [to] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperationLogEntries: async (path?: string, get?: boolean, put?: boolean, post?: boolean, _delete?: boolean, from?: number, to?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/operationslogentry/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }

            if (get !== undefined) {
                localVarQueryParameter['get'] = get;
            }

            if (put !== undefined) {
                localVarQueryParameter['put'] = put;
            }

            if (post !== undefined) {
                localVarQueryParameter['post'] = post;
            }

            if (_delete !== undefined) {
                localVarQueryParameter['delete'] = _delete;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperationLogEntryParam: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getOperationLogEntryParam', 'id', id)
            const localVarPath = `/resources/operationslogentry/{id}/payload`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperationLogEntryResponse: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getOperationLogEntryResponse', 'id', id)
            const localVarPath = `/resources/operationslogentry/{id}/response`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPermissionErrors: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/operationslogentry`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPojoUser: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/users/pojo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [sdate] 
         * @param {number} [edate] 
         * @param {Array<UserInfo>} [userInfo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRadiusLocations: async (sdate?: number, edate?: number, userInfo?: Array<UserInfo>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/clock/radiusLocation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (sdate !== undefined) {
                localVarQueryParameter['sdate'] = sdate;
            }

            if (edate !== undefined) {
                localVarQueryParameter['edate'] = edate;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userInfo, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [userid] 
         * @param {number} [sdate] 
         * @param {number} [edate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRetailStaffShifts: async (userid?: number, sdate?: number, edate?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/shift/retailstaffshifts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (userid !== undefined) {
                localVarQueryParameter['userid'] = userid;
            }

            if (sdate !== undefined) {
                localVarQueryParameter['sdate'] = sdate;
            }

            if (edate !== undefined) {
                localVarQueryParameter['edate'] = edate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatusForUserName: async (userName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userName' is not null or undefined
            assertParamExists('getStatusForUserName', 'userName', userName)
            const localVarPath = `/resources/users/getstatus/{userName}`
                .replace(`{${"userName"}}`, encodeURIComponent(String(userName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [storeids] 
         * @param {number} [sdate] 
         * @param {number} [edate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStoreShiftPeriods: async (storeids?: string, sdate?: number, edate?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/shift/periodfilter`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (storeids !== undefined) {
                localVarQueryParameter['storeids'] = storeids;
            }

            if (sdate !== undefined) {
                localVarQueryParameter['sdate'] = sdate;
            }

            if (edate !== undefined) {
                localVarQueryParameter['edate'] = edate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [storeid] 
         * @param {number} [sdate] 
         * @param {number} [edate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStoreShifts: async (storeid?: number, sdate?: number, edate?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/shift/storeshifts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (storeid !== undefined) {
                localVarQueryParameter['storeid'] = storeid;
            }

            if (sdate !== undefined) {
                localVarQueryParameter['sdate'] = sdate;
            }

            if (edate !== undefined) {
                localVarQueryParameter['edate'] = edate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserApps: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/usergroups/userApps`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} groupid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAssociation: async (groupid: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupid' is not null or undefined
            assertParamExists('getUserAssociation', 'groupid', groupid)
            const localVarPath = `/resources/usergroups/{groupid}/users/association`
                .replace(`{${"groupid"}}`, encodeURIComponent(String(groupid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} userid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAssociationGroups: async (userid: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userid' is not null or undefined
            assertParamExists('getUserAssociationGroups', 'userid', userid)
            const localVarPath = `/resources/users/{userid}/usergroups/association`
                .replace(`{${"userid"}}`, encodeURIComponent(String(userid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} userid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserGroups: async (userid: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userid' is not null or undefined
            assertParamExists('getUserGroups', 'userid', userid)
            const localVarPath = `/resources/users/{userid}/usergroups`
                .replace(`{${"userid"}}`, encodeURIComponent(String(userid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [appID] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserGroupsByApp: async (appID?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/usergroups/appUserGroups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (appID !== undefined) {
                localVarQueryParameter['appID'] = appID;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserGroupsForUser: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/usergroups/getUserGroupsForUser`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<number>} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserInfo: async (requestBody?: Array<number>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/users/userinfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} userid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserMethods: async (userid: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userid' is not null or undefined
            assertParamExists('getUserMethods', 'userid', userid)
            const localVarPath = `/resources/users/{userid}/usermethods`
                .replace(`{${"userid"}}`, encodeURIComponent(String(userid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} userid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserParent: async (userid: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userid' is not null or undefined
            assertParamExists('getUserParent', 'userid', userid)
            const localVarPath = `/resources/users/{userid}/parent`
                .replace(`{${"userid"}}`, encodeURIComponent(String(userid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} userid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTree: async (userid: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userid' is not null or undefined
            assertParamExists('getUserTree', 'userid', userid)
            const localVarPath = `/resources/users/{userid}/tree`
                .replace(`{${"userid"}}`, encodeURIComponent(String(userid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {StringList} [stringList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserUserGroups: async (stringList?: StringList, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/usergroups/userHasGroups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(stringList, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsernamesAndIds: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/users/getUsernameAndIds`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} groupid 
         * @param {Array<string>} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersByGroups: async (groupid: number, requestBody?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupid' is not null or undefined
            assertParamExists('getUsersByGroups', 'groupid', groupid)
            const localVarPath = `/resources/users/findbygroups`
                .replace(`{${"groupid"}}`, encodeURIComponent(String(groupid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} groupid 
         * @param {number} [companyid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersForGroup: async (groupid: number, companyid?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupid' is not null or undefined
            assertParamExists('getUsersForGroup', 'groupid', groupid)
            const localVarPath = `/resources/usergroups/{groupid}/users`
                .replace(`{${"groupid"}}`, encodeURIComponent(String(groupid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (companyid !== undefined) {
                localVarQueryParameter['companyid'] = companyid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} businessGroupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserslist: async (businessGroupId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessGroupId' is not null or undefined
            assertParamExists('getUserslist', 'businessGroupId', businessGroupId)
            const localVarPath = `/resources/businessgroup/{businessGroupId}/userslist`
                .replace(`{${"businessGroupId"}}`, encodeURIComponent(String(businessGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [userGroups] 
         * @param {AccessRequest} [accessRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giveRequestAccess: async (userGroups?: number, accessRequest?: AccessRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/accessrequest/giveaccess`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (userGroups !== undefined) {
                localVarQueryParameter['userGroups'] = userGroups;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accessRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBusinessGroups: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/businessgroup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMethods: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/methods`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMyUsers: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/clock/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMyUsers1: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/task/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/users/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} userid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoff: async (userid: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userid' is not null or undefined
            assertParamExists('logoff', 'userid', userid)
            const localVarPath = `/resources/users/{userid}/logoff`
                .replace(`{${"userid"}}`, encodeURIComponent(String(userid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} userid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logon: async (userid: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userid' is not null or undefined
            assertParamExists('logon', 'userid', userid)
            const localVarPath = `/resources/users/{userid}/logon`
                .replace(`{${"userid"}}`, encodeURIComponent(String(userid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        remove: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('remove', 'id', id)
            const localVarPath = `/resources/clock/delete/id:{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} methodid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        remove1: async (methodid: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'methodid' is not null or undefined
            assertParamExists('remove1', 'methodid', methodid)
            const localVarPath = `/resources/methods/{methodid}/delete`
                .replace(`{${"methodid"}}`, encodeURIComponent(String(methodid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Users} [users] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        remove2: async (users?: Users, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(users, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [retailstaffshiftid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeRetailStaffShift: async (retailstaffshiftid?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/shift/removeretailstaffshift`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (retailstaffshiftid !== undefined) {
                localVarQueryParameter['retailstaffshiftid'] = retailstaffshiftid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [storeshiftid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeStoreShift: async (storeshiftid?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/shift/removestoreshift`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (storeshiftid !== undefined) {
                localVarQueryParameter['storeshiftid'] = storeshiftid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [emailAddress] 
         * @param {string} [cellNumber] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reset: async (emailAddress?: string, cellNumber?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/users/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (emailAddress !== undefined) {
                localVarQueryParameter['emailAddress'] = emailAddress;
            }

            if (cellNumber !== undefined) {
                localVarQueryParameter['cellNumber'] = cellNumber;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Users} [users] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPassword: async (users?: Users, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/users/resetPassword`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(users, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [username] 
         * @param {string} [contactnumber] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchForUsers: async (username?: string, contactnumber?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/users/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }

            if (contactnumber !== undefined) {
                localVarQueryParameter['contactnumber'] = contactnumber;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [userid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchResultsTree: async (userid?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/users/searchResultsTree`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (userid !== undefined) {
                localVarQueryParameter['userid'] = userid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [substring] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUsersSubstring: async (substring?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/users/searchUsers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (substring !== undefined) {
                localVarQueryParameter['substring'] = substring;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {BulkSMS} [bulkSMS] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendBulkSMS: async (bulkSMS?: BulkSMS, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/mqtest/bulksms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkSMS, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WhatsappIncommingObj} [whatsappIncommingObj] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendWhatappTextMessage: async (whatsappIncommingObj?: WhatsappIncommingObj, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/whatsapp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(whatsappIncommingObj, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ChangePasswordRequest} [changePasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPasswordForUsername: async (changePasswordRequest?: ChangePasswordRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/users/setPasswordForUsername`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(changePasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} userid 
         * @param {UserGroupIdList} [userGroupIdList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUserAssociationGroups: async (userid: number, userGroupIdList?: UserGroupIdList, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userid' is not null or undefined
            assertParamExists('setUserAssociationGroups', 'userid', userid)
            const localVarPath = `/resources/users/{userid}/usergroups/association`
                .replace(`{${"userid"}}`, encodeURIComponent(String(userid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userGroupIdList, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} userid 
         * @param {UserIdList} [userIdList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUsersSubUsers: async (userid: number, userIdList?: UserIdList, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userid' is not null or undefined
            assertParamExists('setUsersSubUsers', 'userid', userid)
            const localVarPath = `/resources/users/{userid}/subusers`
                .replace(`{${"userid"}}`, encodeURIComponent(String(userid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userIdList, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} userId 
         * @param {number} subscribeBoolean 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscribeNetClockNotification: async (userId: number, subscribeBoolean: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('subscribeNetClockNotification', 'userId', userId)
            // verify required parameter 'subscribeBoolean' is not null or undefined
            assertParamExists('subscribeNetClockNotification', 'subscribeBoolean', subscribeBoolean)
            const localVarPath = `/resources/whatsapp/subscribe/{userId}/netclock/{subscribeBoolean}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"subscribeBoolean"}}`, encodeURIComponent(String(subscribeBoolean)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeTypeSelection: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/timeType`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Clock} [clock] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTimesheetEntry: async (clock?: Clock, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/clock/updateTimesheetEntry`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clock, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} settingid 
         * @param {UserSetting} [userSetting] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserSetting: async (settingid: number, userSetting?: UserSetting, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'settingid' is not null or undefined
            assertParamExists('updateUserSetting', 'settingid', settingid)
            const localVarPath = `/resources/setting/{settingid}/user`
                .replace(`{${"settingid"}}`, encodeURIComponent(String(settingid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userSetting, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userHasGroup: async (groupName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupName' is not null or undefined
            assertParamExists('userHasGroup', 'groupName', groupName)
            const localVarPath = `/resources/usergroups/userHasGroup/{groupName}`
                .replace(`{${"groupName"}}`, encodeURIComponent(String(groupName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [id] 
         * @param {number} [timestamp] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userTimestampData: async (id?: number, timestamp?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/clock/userTimestampData`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [hubMode] 
         * @param {number} [hubChallenge] 
         * @param {string} [hubVerifyToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verificationRequest: async (hubMode?: string, hubChallenge?: number, hubVerifyToken?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/whatsapp/webhooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (hubMode !== undefined) {
                localVarQueryParameter['hub.mode'] = hubMode;
            }

            if (hubChallenge !== undefined) {
                localVarQueryParameter['hub.challenge'] = hubChallenge;
            }

            if (hubVerifyToken !== undefined) {
                localVarQueryParameter['hub.verify_token'] = hubVerifyToken;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {UserGroups} [userGroups] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(userGroups?: UserGroups, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._delete(userGroups, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Array<Shifts>} [shifts] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addNewShiftList(shifts?: Array<Shifts>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addNewShiftList(shifts, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [oldAssignedDate] 
         * @param {Array<Shifts>} [shifts] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addShifts(oldAssignedDate?: number, shifts?: Array<Shifts>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addShifts(oldAssignedDate, shifts, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Clock} [clock] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addTimesheetEntry(clock?: Clock, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addTimesheetEntry(clock, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {TaskRef} [taskRef] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async approveTask(taskRef?: TaskRef, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.approveTask(taskRef, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} groupid 
         * @param {AssignedMethodIdsForGroupId} [assignedMethodIdsForGroupId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assignMethods(groupid: number, assignedMethodIdsForGroupId?: AssignedMethodIdsForGroupId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assignMethods(groupid, assignedMethodIdsForGroupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} userid 
         * @param {AssignedMethodIdsForUserId} [assignedMethodIdsForUserId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assignMethods1(userid: number, assignedMethodIdsForUserId?: AssignedMethodIdsForUserId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assignMethods1(userid, assignedMethodIdsForUserId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Array<Shifts>} [shifts] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assignShiftListToStores(shifts?: Array<Shifts>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assignShiftListToStores(shifts, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Shifts} [shifts] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assignShiftToStore(shifts?: Shifts, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assignShiftToStore(shifts, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {RetailStaffShifts} [retailStaffShifts] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assignToUser(retailStaffShifts?: RetailStaffShifts, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assignToUser(retailStaffShifts, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} groupid 
         * @param {AssignedUserIdsForGroupId} [assignedUserIdsForGroupId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assignUserAssociation(groupid: number, assignedUserIdsForGroupId?: AssignedUserIdsForGroupId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assignUserAssociation(groupid, assignedUserIdsForGroupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} userid 
         * @param {AssignedGroupIdsForUserId} [assignedGroupIdsForUserId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assignUserGroups(userid: number, assignedGroupIdsForUserId?: AssignedGroupIdsForUserId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assignUserGroups(userid, assignedGroupIdsForUserId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} groupid 
         * @param {AssignedUserIdsForGroupId} [assignedUserIdsForGroupId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assignUsers(groupid: number, assignedUserIdsForGroupId?: AssignedUserIdsForGroupId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assignUsers(groupid, assignedUserIdsForGroupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {MethodAuthCheck} [methodAuthCheck] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async canRemoteUserDo(methodAuthCheck?: MethodAuthCheck, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.canRemoteUserDo(methodAuthCheck, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} userid 
         * @param {string} [password] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changePassword(userid: number, password?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changePassword(userid, password, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {UserHttpCalls} [userHttpCalls] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkUserAllowedHttpMethods(userHttpCalls?: UserHttpCalls, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkUserAllowedHttpMethods(userHttpCalls, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [userName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clearCache(userName?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clearCache(userName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Array<Clock>} [clock] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clockIn(clock?: Array<Clock>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clockIn(clock, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async companyStructureLists(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.companyStructureLists(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Methods} [methods] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(methods?: Methods, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(methods, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {UserGroups} [userGroups] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create1(userGroups?: UserGroups, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create1(userGroups, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Array<Task>} [task] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTask(task?: Array<Task>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTask(task, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {boolean} [customerportal] 
         * @param {Users} [users] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserFromToken(customerportal?: boolean, users?: Users, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserFromToken(customerportal, users, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} settingid 
         * @param {UserSetting} [userSetting] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserSetting(settingid: number, userSetting?: UserSetting, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserSetting(settingid, userSetting, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Array<AccessRequest>} [accessRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createaccessRequest(accessRequest?: Array<AccessRequest>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createaccessRequest(accessRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [requestId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async declineRequest(requestId?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.declineRequest(requestId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Methods} [methods] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async edit(methods?: Methods, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.edit(methods, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {UserGroups} [userGroups] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async edit1(userGroups?: UserGroups, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.edit1(userGroups, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Users} [users] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async edit2(users?: Users, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.edit2(users, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} userid 
         * @param {string} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editPassword(userid: number, body?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editPassword(userid, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Array<Clock>} [clock] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editTask(clock?: Array<Clock>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editTask(clock, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Array<Task>} [task] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editTask1(task?: Array<Task>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editTask1(task, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventNotification(body?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventNotification(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {User} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async expirePassword(user?: User, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.expirePassword(user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllUserGroups(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllUserGroups(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [companyid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findBusinessGroupByCompany(companyid?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findBusinessGroupByCompany(companyid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} software 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findBySoftware(software: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findBySoftware(software, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} settingid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findByUserAndSettingName(settingid: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findByUserAndSettingName(settingid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} software 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findByUserAndSettingName1(software: string, name: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findByUserAndSettingName1(software, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} software 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findByUserAndSoftware(software: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findByUserAndSoftware(software, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} groupid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findGroup(groupid: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findGroup(groupid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} groupname 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findGroup1(groupname: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findGroup1(groupname, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [path] 
         * @param {string} [httpmethod] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findMethod(path?: string, httpmethod?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findMethod(path, httpmethod, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [topic] 
         * @param {string} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findMethod1(topic?: string, body?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findMethod1(topic, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} methodid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findMethod2(methodid: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findMethod2(methodid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findSubUsers(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findSubUsers(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findSubUsersCascade(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findSubUsersCascade(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findTask(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findTask(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [sdate] 
         * @param {number} [edate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findTasks(sdate?: number, edate?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findTasks(sdate, edate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve user information by user ID
         * @summary Get user information
         * @param {number} userid User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findUser(userid: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Users>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findUser(userid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findUserByUserName(username: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findUserByUserName(username, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {UserList} [userList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findUserIdsByName(userList?: UserList, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findUserIdsByName(userList, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} userid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findUsersSubUsers(userid: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findUsersSubUsers(userid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} oauthprovider 
         * @param {string} username 
         * @param {string} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateUserToken(oauthprovider: string, username: string, body?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateUserToken(oauthprovider, username, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccessRequest(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccessRequest(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [netstoreid] 
         * @param {number} [sdate] 
         * @param {number} [edate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActiveStoreUsers(netstoreid?: number, sdate?: number, edate?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActiveStoreUsers(netstoreid, sdate, edate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAppUserGroupsByUser(userId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAppUserGroupsByUser(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} userid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBranchParent(userid: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBranchParent(userid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} userid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBranchUsers(userid: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBranchUsers(userid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [path] 
         * @param {number} [pageno] 
         * @param {number} [rows] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEndpointTraffic(path?: string, pageno?: number, rows?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEndpointTraffic(path, pageno, rows, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [userName] 
         * @param {string} [path] 
         * @param {string} [methodName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupAndUserAccess(userName?: string, path?: string, methodName?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupAndUserAccess(userName, path, methodName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} groupid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupMethods(groupid: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupMethods(groupid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} groupid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupnamesAndIds(groupid: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupnamesAndIds(groupid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLocations(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLocations(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMainTree(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMainTree(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [path] 
         * @param {boolean} [get] 
         * @param {boolean} [put] 
         * @param {boolean} [post] 
         * @param {boolean} [_delete] 
         * @param {number} [from] 
         * @param {number} [to] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOperationLogEntries(path?: string, get?: boolean, put?: boolean, post?: boolean, _delete?: boolean, from?: number, to?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOperationLogEntries(path, get, put, post, _delete, from, to, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOperationLogEntryParam(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOperationLogEntryParam(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOperationLogEntryResponse(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOperationLogEntryResponse(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPermissionErrors(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPermissionErrors(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPojoUser(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPojoUser(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [sdate] 
         * @param {number} [edate] 
         * @param {Array<UserInfo>} [userInfo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRadiusLocations(sdate?: number, edate?: number, userInfo?: Array<UserInfo>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRadiusLocations(sdate, edate, userInfo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [userid] 
         * @param {number} [sdate] 
         * @param {number} [edate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRetailStaffShifts(userid?: number, sdate?: number, edate?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRetailStaffShifts(userid, sdate, edate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} userName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatusForUserName(userName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatusForUserName(userName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [storeids] 
         * @param {number} [sdate] 
         * @param {number} [edate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStoreShiftPeriods(storeids?: string, sdate?: number, edate?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStoreShiftPeriods(storeids, sdate, edate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [storeid] 
         * @param {number} [sdate] 
         * @param {number} [edate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStoreShifts(storeid?: number, sdate?: number, edate?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStoreShifts(storeid, sdate, edate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserApps(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserApps(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} groupid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserAssociation(groupid: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserAssociation(groupid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} userid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserAssociationGroups(userid: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserAssociationGroups(userid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} userid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserGroups(userid: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserGroups(userid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [appID] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserGroupsByApp(appID?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserGroupsByApp(appID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserGroupsForUser(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserGroupsForUser(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Array<number>} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserInfo(requestBody?: Array<number>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserInfo(requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} userid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserMethods(userid: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserMethods(userid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} userid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserParent(userid: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserParent(userid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} userid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserTree(userid: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserTree(userid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {StringList} [stringList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserUserGroups(stringList?: StringList, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserUserGroups(stringList, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsernamesAndIds(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsernamesAndIds(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} groupid 
         * @param {Array<string>} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersByGroups(groupid: number, requestBody?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersByGroups(groupid, requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} groupid 
         * @param {number} [companyid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersForGroup(groupid: number, companyid?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersForGroup(groupid, companyid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} businessGroupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserslist(businessGroupId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserslist(businessGroupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [userGroups] 
         * @param {AccessRequest} [accessRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async giveRequestAccess(userGroups?: number, accessRequest?: AccessRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.giveRequestAccess(userGroups, accessRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBusinessGroups(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBusinessGroups(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMethods(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMethods(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMyUsers(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMyUsers(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMyUsers1(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMyUsers1(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUsers(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUsers(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} userid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logoff(userid: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logoff(userid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} userid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logon(userid: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logon(userid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async remove(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.remove(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} methodid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async remove1(methodid: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.remove1(methodid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Users} [users] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async remove2(users?: Users, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.remove2(users, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [retailstaffshiftid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeRetailStaffShift(retailstaffshiftid?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeRetailStaffShift(retailstaffshiftid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [storeshiftid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeStoreShift(storeshiftid?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeStoreShift(storeshiftid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [emailAddress] 
         * @param {string} [cellNumber] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reset(emailAddress?: string, cellNumber?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reset(emailAddress, cellNumber, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Users} [users] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetPassword(users?: Users, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetPassword(users, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [username] 
         * @param {string} [contactnumber] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchForUsers(username?: string, contactnumber?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchForUsers(username, contactnumber, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [userid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchResultsTree(userid?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchResultsTree(userid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [substring] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchUsersSubstring(substring?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchUsersSubstring(substring, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {BulkSMS} [bulkSMS] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendBulkSMS(bulkSMS?: BulkSMS, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendBulkSMS(bulkSMS, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WhatsappIncommingObj} [whatsappIncommingObj] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendWhatappTextMessage(whatsappIncommingObj?: WhatsappIncommingObj, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendWhatappTextMessage(whatsappIncommingObj, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ChangePasswordRequest} [changePasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setPasswordForUsername(changePasswordRequest?: ChangePasswordRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setPasswordForUsername(changePasswordRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} userid 
         * @param {UserGroupIdList} [userGroupIdList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setUserAssociationGroups(userid: number, userGroupIdList?: UserGroupIdList, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setUserAssociationGroups(userid, userGroupIdList, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} userid 
         * @param {UserIdList} [userIdList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setUsersSubUsers(userid: number, userIdList?: UserIdList, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setUsersSubUsers(userid, userIdList, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} userId 
         * @param {number} subscribeBoolean 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subscribeNetClockNotification(userId: number, subscribeBoolean: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subscribeNetClockNotification(userId, subscribeBoolean, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async timeTypeSelection(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.timeTypeSelection(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Clock} [clock] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTimesheetEntry(clock?: Clock, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTimesheetEntry(clock, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} settingid 
         * @param {UserSetting} [userSetting] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserSetting(settingid: number, userSetting?: UserSetting, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserSetting(settingid, userSetting, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} groupName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userHasGroup(groupName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userHasGroup(groupName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [id] 
         * @param {number} [timestamp] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userTimestampData(id?: number, timestamp?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userTimestampData(id, timestamp, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [hubMode] 
         * @param {number} [hubChallenge] 
         * @param {string} [hubVerifyToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verificationRequest(hubMode?: string, hubChallenge?: number, hubVerifyToken?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verificationRequest(hubMode, hubChallenge, hubVerifyToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @param {UserGroups} [userGroups] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(userGroups?: UserGroups, options?: any): AxiosPromise<void> {
            return localVarFp._delete(userGroups, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Array<Shifts>} [shifts] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addNewShiftList(shifts?: Array<Shifts>, options?: any): AxiosPromise<void> {
            return localVarFp.addNewShiftList(shifts, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [oldAssignedDate] 
         * @param {Array<Shifts>} [shifts] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addShifts(oldAssignedDate?: number, shifts?: Array<Shifts>, options?: any): AxiosPromise<void> {
            return localVarFp.addShifts(oldAssignedDate, shifts, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Clock} [clock] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTimesheetEntry(clock?: Clock, options?: any): AxiosPromise<void> {
            return localVarFp.addTimesheetEntry(clock, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {TaskRef} [taskRef] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveTask(taskRef?: TaskRef, options?: any): AxiosPromise<void> {
            return localVarFp.approveTask(taskRef, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} groupid 
         * @param {AssignedMethodIdsForGroupId} [assignedMethodIdsForGroupId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignMethods(groupid: number, assignedMethodIdsForGroupId?: AssignedMethodIdsForGroupId, options?: any): AxiosPromise<void> {
            return localVarFp.assignMethods(groupid, assignedMethodIdsForGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} userid 
         * @param {AssignedMethodIdsForUserId} [assignedMethodIdsForUserId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignMethods1(userid: number, assignedMethodIdsForUserId?: AssignedMethodIdsForUserId, options?: any): AxiosPromise<void> {
            return localVarFp.assignMethods1(userid, assignedMethodIdsForUserId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Array<Shifts>} [shifts] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignShiftListToStores(shifts?: Array<Shifts>, options?: any): AxiosPromise<void> {
            return localVarFp.assignShiftListToStores(shifts, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Shifts} [shifts] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignShiftToStore(shifts?: Shifts, options?: any): AxiosPromise<void> {
            return localVarFp.assignShiftToStore(shifts, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RetailStaffShifts} [retailStaffShifts] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignToUser(retailStaffShifts?: RetailStaffShifts, options?: any): AxiosPromise<void> {
            return localVarFp.assignToUser(retailStaffShifts, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} groupid 
         * @param {AssignedUserIdsForGroupId} [assignedUserIdsForGroupId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignUserAssociation(groupid: number, assignedUserIdsForGroupId?: AssignedUserIdsForGroupId, options?: any): AxiosPromise<void> {
            return localVarFp.assignUserAssociation(groupid, assignedUserIdsForGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} userid 
         * @param {AssignedGroupIdsForUserId} [assignedGroupIdsForUserId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignUserGroups(userid: number, assignedGroupIdsForUserId?: AssignedGroupIdsForUserId, options?: any): AxiosPromise<void> {
            return localVarFp.assignUserGroups(userid, assignedGroupIdsForUserId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} groupid 
         * @param {AssignedUserIdsForGroupId} [assignedUserIdsForGroupId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignUsers(groupid: number, assignedUserIdsForGroupId?: AssignedUserIdsForGroupId, options?: any): AxiosPromise<void> {
            return localVarFp.assignUsers(groupid, assignedUserIdsForGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {MethodAuthCheck} [methodAuthCheck] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        canRemoteUserDo(methodAuthCheck?: MethodAuthCheck, options?: any): AxiosPromise<void> {
            return localVarFp.canRemoteUserDo(methodAuthCheck, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} userid 
         * @param {string} [password] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword(userid: number, password?: string, options?: any): AxiosPromise<void> {
            return localVarFp.changePassword(userid, password, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UserHttpCalls} [userHttpCalls] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkUserAllowedHttpMethods(userHttpCalls?: UserHttpCalls, options?: any): AxiosPromise<void> {
            return localVarFp.checkUserAllowedHttpMethods(userHttpCalls, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [userName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearCache(userName?: string, options?: any): AxiosPromise<void> {
            return localVarFp.clearCache(userName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Array<Clock>} [clock] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clockIn(clock?: Array<Clock>, options?: any): AxiosPromise<void> {
            return localVarFp.clockIn(clock, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyStructureLists(options?: any): AxiosPromise<void> {
            return localVarFp.companyStructureLists(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Methods} [methods] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(methods?: Methods, options?: any): AxiosPromise<void> {
            return localVarFp.create(methods, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UserGroups} [userGroups] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create1(userGroups?: UserGroups, options?: any): AxiosPromise<void> {
            return localVarFp.create1(userGroups, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Array<Task>} [task] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTask(task?: Array<Task>, options?: any): AxiosPromise<void> {
            return localVarFp.createTask(task, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {boolean} [customerportal] 
         * @param {Users} [users] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserFromToken(customerportal?: boolean, users?: Users, options?: any): AxiosPromise<void> {
            return localVarFp.createUserFromToken(customerportal, users, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} settingid 
         * @param {UserSetting} [userSetting] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserSetting(settingid: number, userSetting?: UserSetting, options?: any): AxiosPromise<void> {
            return localVarFp.createUserSetting(settingid, userSetting, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Array<AccessRequest>} [accessRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createaccessRequest(accessRequest?: Array<AccessRequest>, options?: any): AxiosPromise<void> {
            return localVarFp.createaccessRequest(accessRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [requestId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        declineRequest(requestId?: number, options?: any): AxiosPromise<void> {
            return localVarFp.declineRequest(requestId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Methods} [methods] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edit(methods?: Methods, options?: any): AxiosPromise<void> {
            return localVarFp.edit(methods, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UserGroups} [userGroups] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edit1(userGroups?: UserGroups, options?: any): AxiosPromise<void> {
            return localVarFp.edit1(userGroups, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Users} [users] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edit2(users?: Users, options?: any): AxiosPromise<void> {
            return localVarFp.edit2(users, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} userid 
         * @param {string} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editPassword(userid: number, body?: string, options?: any): AxiosPromise<void> {
            return localVarFp.editPassword(userid, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Array<Clock>} [clock] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editTask(clock?: Array<Clock>, options?: any): AxiosPromise<void> {
            return localVarFp.editTask(clock, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Array<Task>} [task] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editTask1(task?: Array<Task>, options?: any): AxiosPromise<void> {
            return localVarFp.editTask1(task, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventNotification(body?: string, options?: any): AxiosPromise<void> {
            return localVarFp.eventNotification(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {User} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expirePassword(user?: User, options?: any): AxiosPromise<void> {
            return localVarFp.expirePassword(user, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllUserGroups(options?: any): AxiosPromise<void> {
            return localVarFp.findAllUserGroups(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [companyid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findBusinessGroupByCompany(companyid?: number, options?: any): AxiosPromise<void> {
            return localVarFp.findBusinessGroupByCompany(companyid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} software 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findBySoftware(software: string, options?: any): AxiosPromise<void> {
            return localVarFp.findBySoftware(software, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} settingid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findByUserAndSettingName(settingid: number, options?: any): AxiosPromise<void> {
            return localVarFp.findByUserAndSettingName(settingid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} software 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findByUserAndSettingName1(software: string, name: string, options?: any): AxiosPromise<void> {
            return localVarFp.findByUserAndSettingName1(software, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} software 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findByUserAndSoftware(software: string, options?: any): AxiosPromise<void> {
            return localVarFp.findByUserAndSoftware(software, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} groupid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findGroup(groupid: number, options?: any): AxiosPromise<void> {
            return localVarFp.findGroup(groupid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} groupname 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findGroup1(groupname: string, options?: any): AxiosPromise<void> {
            return localVarFp.findGroup1(groupname, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [path] 
         * @param {string} [httpmethod] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findMethod(path?: string, httpmethod?: string, options?: any): AxiosPromise<void> {
            return localVarFp.findMethod(path, httpmethod, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [topic] 
         * @param {string} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findMethod1(topic?: string, body?: string, options?: any): AxiosPromise<void> {
            return localVarFp.findMethod1(topic, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} methodid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findMethod2(methodid: number, options?: any): AxiosPromise<void> {
            return localVarFp.findMethod2(methodid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSubUsers(options?: any): AxiosPromise<void> {
            return localVarFp.findSubUsers(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSubUsersCascade(options?: any): AxiosPromise<void> {
            return localVarFp.findSubUsersCascade(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTask(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.findTask(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [sdate] 
         * @param {number} [edate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTasks(sdate?: number, edate?: number, options?: any): AxiosPromise<void> {
            return localVarFp.findTasks(sdate, edate, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve user information by user ID
         * @summary Get user information
         * @param {number} userid User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUser(userid: number, options?: any): AxiosPromise<Users> {
            return localVarFp.findUser(userid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUserByUserName(username: string, options?: any): AxiosPromise<void> {
            return localVarFp.findUserByUserName(username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UserList} [userList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUserIdsByName(userList?: UserList, options?: any): AxiosPromise<void> {
            return localVarFp.findUserIdsByName(userList, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} userid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUsersSubUsers(userid: number, options?: any): AxiosPromise<void> {
            return localVarFp.findUsersSubUsers(userid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} oauthprovider 
         * @param {string} username 
         * @param {string} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateUserToken(oauthprovider: string, username: string, body?: string, options?: any): AxiosPromise<void> {
            return localVarFp.generateUserToken(oauthprovider, username, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccessRequest(options?: any): AxiosPromise<void> {
            return localVarFp.getAccessRequest(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [netstoreid] 
         * @param {number} [sdate] 
         * @param {number} [edate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveStoreUsers(netstoreid?: number, sdate?: number, edate?: number, options?: any): AxiosPromise<void> {
            return localVarFp.getActiveStoreUsers(netstoreid, sdate, edate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAppUserGroupsByUser(userId: number, options?: any): AxiosPromise<void> {
            return localVarFp.getAppUserGroupsByUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} userid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBranchParent(userid: number, options?: any): AxiosPromise<void> {
            return localVarFp.getBranchParent(userid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} userid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBranchUsers(userid: number, options?: any): AxiosPromise<void> {
            return localVarFp.getBranchUsers(userid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [path] 
         * @param {number} [pageno] 
         * @param {number} [rows] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEndpointTraffic(path?: string, pageno?: number, rows?: number, options?: any): AxiosPromise<void> {
            return localVarFp.getEndpointTraffic(path, pageno, rows, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [userName] 
         * @param {string} [path] 
         * @param {string} [methodName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupAndUserAccess(userName?: string, path?: string, methodName?: string, options?: any): AxiosPromise<void> {
            return localVarFp.getGroupAndUserAccess(userName, path, methodName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} groupid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupMethods(groupid: number, options?: any): AxiosPromise<void> {
            return localVarFp.getGroupMethods(groupid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} groupid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupnamesAndIds(groupid: number, options?: any): AxiosPromise<void> {
            return localVarFp.getGroupnamesAndIds(groupid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLocations(options?: any): AxiosPromise<void> {
            return localVarFp.getLocations(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMainTree(options?: any): AxiosPromise<void> {
            return localVarFp.getMainTree(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [path] 
         * @param {boolean} [get] 
         * @param {boolean} [put] 
         * @param {boolean} [post] 
         * @param {boolean} [_delete] 
         * @param {number} [from] 
         * @param {number} [to] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperationLogEntries(path?: string, get?: boolean, put?: boolean, post?: boolean, _delete?: boolean, from?: number, to?: number, options?: any): AxiosPromise<void> {
            return localVarFp.getOperationLogEntries(path, get, put, post, _delete, from, to, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperationLogEntryParam(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.getOperationLogEntryParam(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperationLogEntryResponse(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.getOperationLogEntryResponse(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPermissionErrors(options?: any): AxiosPromise<void> {
            return localVarFp.getPermissionErrors(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPojoUser(options?: any): AxiosPromise<void> {
            return localVarFp.getPojoUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [sdate] 
         * @param {number} [edate] 
         * @param {Array<UserInfo>} [userInfo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRadiusLocations(sdate?: number, edate?: number, userInfo?: Array<UserInfo>, options?: any): AxiosPromise<void> {
            return localVarFp.getRadiusLocations(sdate, edate, userInfo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [userid] 
         * @param {number} [sdate] 
         * @param {number} [edate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRetailStaffShifts(userid?: number, sdate?: number, edate?: number, options?: any): AxiosPromise<void> {
            return localVarFp.getRetailStaffShifts(userid, sdate, edate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatusForUserName(userName: string, options?: any): AxiosPromise<void> {
            return localVarFp.getStatusForUserName(userName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [storeids] 
         * @param {number} [sdate] 
         * @param {number} [edate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStoreShiftPeriods(storeids?: string, sdate?: number, edate?: number, options?: any): AxiosPromise<void> {
            return localVarFp.getStoreShiftPeriods(storeids, sdate, edate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [storeid] 
         * @param {number} [sdate] 
         * @param {number} [edate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStoreShifts(storeid?: number, sdate?: number, edate?: number, options?: any): AxiosPromise<void> {
            return localVarFp.getStoreShifts(storeid, sdate, edate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserApps(options?: any): AxiosPromise<void> {
            return localVarFp.getUserApps(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} groupid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAssociation(groupid: number, options?: any): AxiosPromise<void> {
            return localVarFp.getUserAssociation(groupid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} userid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAssociationGroups(userid: number, options?: any): AxiosPromise<void> {
            return localVarFp.getUserAssociationGroups(userid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} userid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserGroups(userid: number, options?: any): AxiosPromise<void> {
            return localVarFp.getUserGroups(userid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [appID] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserGroupsByApp(appID?: number, options?: any): AxiosPromise<void> {
            return localVarFp.getUserGroupsByApp(appID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserGroupsForUser(options?: any): AxiosPromise<void> {
            return localVarFp.getUserGroupsForUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Array<number>} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserInfo(requestBody?: Array<number>, options?: any): AxiosPromise<void> {
            return localVarFp.getUserInfo(requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} userid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserMethods(userid: number, options?: any): AxiosPromise<void> {
            return localVarFp.getUserMethods(userid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} userid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserParent(userid: number, options?: any): AxiosPromise<void> {
            return localVarFp.getUserParent(userid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} userid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTree(userid: number, options?: any): AxiosPromise<void> {
            return localVarFp.getUserTree(userid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {StringList} [stringList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserUserGroups(stringList?: StringList, options?: any): AxiosPromise<void> {
            return localVarFp.getUserUserGroups(stringList, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsernamesAndIds(options?: any): AxiosPromise<void> {
            return localVarFp.getUsernamesAndIds(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} groupid 
         * @param {Array<string>} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersByGroups(groupid: number, requestBody?: Array<string>, options?: any): AxiosPromise<void> {
            return localVarFp.getUsersByGroups(groupid, requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} groupid 
         * @param {number} [companyid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersForGroup(groupid: number, companyid?: number, options?: any): AxiosPromise<void> {
            return localVarFp.getUsersForGroup(groupid, companyid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} businessGroupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserslist(businessGroupId: number, options?: any): AxiosPromise<void> {
            return localVarFp.getUserslist(businessGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [userGroups] 
         * @param {AccessRequest} [accessRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giveRequestAccess(userGroups?: number, accessRequest?: AccessRequest, options?: any): AxiosPromise<void> {
            return localVarFp.giveRequestAccess(userGroups, accessRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBusinessGroups(options?: any): AxiosPromise<void> {
            return localVarFp.listBusinessGroups(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMethods(options?: any): AxiosPromise<void> {
            return localVarFp.listMethods(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMyUsers(options?: any): AxiosPromise<void> {
            return localVarFp.listMyUsers(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMyUsers1(options?: any): AxiosPromise<void> {
            return localVarFp.listMyUsers1(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers(options?: any): AxiosPromise<void> {
            return localVarFp.listUsers(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(options?: any): AxiosPromise<void> {
            return localVarFp.login(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} userid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoff(userid: number, options?: any): AxiosPromise<void> {
            return localVarFp.logoff(userid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} userid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logon(userid: number, options?: any): AxiosPromise<void> {
            return localVarFp.logon(userid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        remove(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.remove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} methodid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        remove1(methodid: number, options?: any): AxiosPromise<void> {
            return localVarFp.remove1(methodid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Users} [users] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        remove2(users?: Users, options?: any): AxiosPromise<void> {
            return localVarFp.remove2(users, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [retailstaffshiftid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeRetailStaffShift(retailstaffshiftid?: number, options?: any): AxiosPromise<void> {
            return localVarFp.removeRetailStaffShift(retailstaffshiftid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [storeshiftid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeStoreShift(storeshiftid?: number, options?: any): AxiosPromise<void> {
            return localVarFp.removeStoreShift(storeshiftid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [emailAddress] 
         * @param {string} [cellNumber] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reset(emailAddress?: string, cellNumber?: string, options?: any): AxiosPromise<void> {
            return localVarFp.reset(emailAddress, cellNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Users} [users] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPassword(users?: Users, options?: any): AxiosPromise<void> {
            return localVarFp.resetPassword(users, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [username] 
         * @param {string} [contactnumber] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchForUsers(username?: string, contactnumber?: string, options?: any): AxiosPromise<void> {
            return localVarFp.searchForUsers(username, contactnumber, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [userid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchResultsTree(userid?: number, options?: any): AxiosPromise<void> {
            return localVarFp.searchResultsTree(userid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [substring] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUsersSubstring(substring?: string, options?: any): AxiosPromise<void> {
            return localVarFp.searchUsersSubstring(substring, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {BulkSMS} [bulkSMS] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendBulkSMS(bulkSMS?: BulkSMS, options?: any): AxiosPromise<void> {
            return localVarFp.sendBulkSMS(bulkSMS, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WhatsappIncommingObj} [whatsappIncommingObj] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendWhatappTextMessage(whatsappIncommingObj?: WhatsappIncommingObj, options?: any): AxiosPromise<void> {
            return localVarFp.sendWhatappTextMessage(whatsappIncommingObj, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ChangePasswordRequest} [changePasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPasswordForUsername(changePasswordRequest?: ChangePasswordRequest, options?: any): AxiosPromise<void> {
            return localVarFp.setPasswordForUsername(changePasswordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} userid 
         * @param {UserGroupIdList} [userGroupIdList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUserAssociationGroups(userid: number, userGroupIdList?: UserGroupIdList, options?: any): AxiosPromise<void> {
            return localVarFp.setUserAssociationGroups(userid, userGroupIdList, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} userid 
         * @param {UserIdList} [userIdList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUsersSubUsers(userid: number, userIdList?: UserIdList, options?: any): AxiosPromise<void> {
            return localVarFp.setUsersSubUsers(userid, userIdList, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} userId 
         * @param {number} subscribeBoolean 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscribeNetClockNotification(userId: number, subscribeBoolean: number, options?: any): AxiosPromise<void> {
            return localVarFp.subscribeNetClockNotification(userId, subscribeBoolean, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeTypeSelection(options?: any): AxiosPromise<void> {
            return localVarFp.timeTypeSelection(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Clock} [clock] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTimesheetEntry(clock?: Clock, options?: any): AxiosPromise<void> {
            return localVarFp.updateTimesheetEntry(clock, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} settingid 
         * @param {UserSetting} [userSetting] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserSetting(settingid: number, userSetting?: UserSetting, options?: any): AxiosPromise<void> {
            return localVarFp.updateUserSetting(settingid, userSetting, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} groupName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userHasGroup(groupName: string, options?: any): AxiosPromise<void> {
            return localVarFp.userHasGroup(groupName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [id] 
         * @param {number} [timestamp] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userTimestampData(id?: number, timestamp?: number, options?: any): AxiosPromise<void> {
            return localVarFp.userTimestampData(id, timestamp, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [hubMode] 
         * @param {number} [hubChallenge] 
         * @param {string} [hubVerifyToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verificationRequest(hubMode?: string, hubChallenge?: number, hubVerifyToken?: string, options?: any): AxiosPromise<void> {
            return localVarFp.verificationRequest(hubMode, hubChallenge, hubVerifyToken, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @param {UserGroups} [userGroups] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public _delete(userGroups?: UserGroups, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration)._delete(userGroups, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Array<Shifts>} [shifts] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public addNewShiftList(shifts?: Array<Shifts>, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).addNewShiftList(shifts, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [oldAssignedDate] 
     * @param {Array<Shifts>} [shifts] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public addShifts(oldAssignedDate?: number, shifts?: Array<Shifts>, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).addShifts(oldAssignedDate, shifts, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Clock} [clock] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public addTimesheetEntry(clock?: Clock, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).addTimesheetEntry(clock, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TaskRef} [taskRef] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public approveTask(taskRef?: TaskRef, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).approveTask(taskRef, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} groupid 
     * @param {AssignedMethodIdsForGroupId} [assignedMethodIdsForGroupId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public assignMethods(groupid: number, assignedMethodIdsForGroupId?: AssignedMethodIdsForGroupId, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).assignMethods(groupid, assignedMethodIdsForGroupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} userid 
     * @param {AssignedMethodIdsForUserId} [assignedMethodIdsForUserId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public assignMethods1(userid: number, assignedMethodIdsForUserId?: AssignedMethodIdsForUserId, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).assignMethods1(userid, assignedMethodIdsForUserId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Array<Shifts>} [shifts] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public assignShiftListToStores(shifts?: Array<Shifts>, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).assignShiftListToStores(shifts, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Shifts} [shifts] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public assignShiftToStore(shifts?: Shifts, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).assignShiftToStore(shifts, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RetailStaffShifts} [retailStaffShifts] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public assignToUser(retailStaffShifts?: RetailStaffShifts, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).assignToUser(retailStaffShifts, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} groupid 
     * @param {AssignedUserIdsForGroupId} [assignedUserIdsForGroupId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public assignUserAssociation(groupid: number, assignedUserIdsForGroupId?: AssignedUserIdsForGroupId, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).assignUserAssociation(groupid, assignedUserIdsForGroupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} userid 
     * @param {AssignedGroupIdsForUserId} [assignedGroupIdsForUserId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public assignUserGroups(userid: number, assignedGroupIdsForUserId?: AssignedGroupIdsForUserId, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).assignUserGroups(userid, assignedGroupIdsForUserId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} groupid 
     * @param {AssignedUserIdsForGroupId} [assignedUserIdsForGroupId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public assignUsers(groupid: number, assignedUserIdsForGroupId?: AssignedUserIdsForGroupId, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).assignUsers(groupid, assignedUserIdsForGroupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {MethodAuthCheck} [methodAuthCheck] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public canRemoteUserDo(methodAuthCheck?: MethodAuthCheck, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).canRemoteUserDo(methodAuthCheck, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} userid 
     * @param {string} [password] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public changePassword(userid: number, password?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).changePassword(userid, password, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserHttpCalls} [userHttpCalls] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public checkUserAllowedHttpMethods(userHttpCalls?: UserHttpCalls, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).checkUserAllowedHttpMethods(userHttpCalls, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [userName] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public clearCache(userName?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).clearCache(userName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Array<Clock>} [clock] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public clockIn(clock?: Array<Clock>, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).clockIn(clock, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public companyStructureLists(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).companyStructureLists(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Methods} [methods] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public create(methods?: Methods, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).create(methods, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserGroups} [userGroups] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public create1(userGroups?: UserGroups, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).create1(userGroups, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Array<Task>} [task] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createTask(task?: Array<Task>, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createTask(task, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {boolean} [customerportal] 
     * @param {Users} [users] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createUserFromToken(customerportal?: boolean, users?: Users, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createUserFromToken(customerportal, users, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} settingid 
     * @param {UserSetting} [userSetting] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createUserSetting(settingid: number, userSetting?: UserSetting, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createUserSetting(settingid, userSetting, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Array<AccessRequest>} [accessRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createaccessRequest(accessRequest?: Array<AccessRequest>, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createaccessRequest(accessRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [requestId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public declineRequest(requestId?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).declineRequest(requestId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Methods} [methods] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public edit(methods?: Methods, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).edit(methods, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserGroups} [userGroups] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public edit1(userGroups?: UserGroups, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).edit1(userGroups, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Users} [users] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public edit2(users?: Users, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).edit2(users, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} userid 
     * @param {string} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public editPassword(userid: number, body?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).editPassword(userid, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Array<Clock>} [clock] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public editTask(clock?: Array<Clock>, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).editTask(clock, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Array<Task>} [task] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public editTask1(task?: Array<Task>, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).editTask1(task, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public eventNotification(body?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).eventNotification(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {User} [user] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public expirePassword(user?: User, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).expirePassword(user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public findAllUserGroups(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).findAllUserGroups(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [companyid] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public findBusinessGroupByCompany(companyid?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).findBusinessGroupByCompany(companyid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} software 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public findBySoftware(software: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).findBySoftware(software, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} settingid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public findByUserAndSettingName(settingid: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).findByUserAndSettingName(settingid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} software 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public findByUserAndSettingName1(software: string, name: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).findByUserAndSettingName1(software, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} software 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public findByUserAndSoftware(software: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).findByUserAndSoftware(software, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} groupid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public findGroup(groupid: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).findGroup(groupid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} groupname 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public findGroup1(groupname: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).findGroup1(groupname, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [path] 
     * @param {string} [httpmethod] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public findMethod(path?: string, httpmethod?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).findMethod(path, httpmethod, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [topic] 
     * @param {string} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public findMethod1(topic?: string, body?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).findMethod1(topic, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} methodid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public findMethod2(methodid: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).findMethod2(methodid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public findSubUsers(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).findSubUsers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public findSubUsersCascade(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).findSubUsersCascade(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public findTask(id: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).findTask(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [sdate] 
     * @param {number} [edate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public findTasks(sdate?: number, edate?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).findTasks(sdate, edate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve user information by user ID
     * @summary Get user information
     * @param {number} userid User ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public findUser(userid: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).findUser(userid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} username 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public findUserByUserName(username: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).findUserByUserName(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserList} [userList] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public findUserIdsByName(userList?: UserList, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).findUserIdsByName(userList, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} userid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public findUsersSubUsers(userid: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).findUsersSubUsers(userid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} oauthprovider 
     * @param {string} username 
     * @param {string} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public generateUserToken(oauthprovider: string, username: string, body?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).generateUserToken(oauthprovider, username, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getAccessRequest(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getAccessRequest(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [netstoreid] 
     * @param {number} [sdate] 
     * @param {number} [edate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getActiveStoreUsers(netstoreid?: number, sdate?: number, edate?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getActiveStoreUsers(netstoreid, sdate, edate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getAppUserGroupsByUser(userId: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getAppUserGroupsByUser(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} userid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getBranchParent(userid: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getBranchParent(userid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} userid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getBranchUsers(userid: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getBranchUsers(userid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [path] 
     * @param {number} [pageno] 
     * @param {number} [rows] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getEndpointTraffic(path?: string, pageno?: number, rows?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getEndpointTraffic(path, pageno, rows, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [userName] 
     * @param {string} [path] 
     * @param {string} [methodName] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getGroupAndUserAccess(userName?: string, path?: string, methodName?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getGroupAndUserAccess(userName, path, methodName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} groupid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getGroupMethods(groupid: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getGroupMethods(groupid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} groupid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getGroupnamesAndIds(groupid: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getGroupnamesAndIds(groupid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getLocations(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getLocations(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getMainTree(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getMainTree(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [path] 
     * @param {boolean} [get] 
     * @param {boolean} [put] 
     * @param {boolean} [post] 
     * @param {boolean} [_delete] 
     * @param {number} [from] 
     * @param {number} [to] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getOperationLogEntries(path?: string, get?: boolean, put?: boolean, post?: boolean, _delete?: boolean, from?: number, to?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getOperationLogEntries(path, get, put, post, _delete, from, to, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getOperationLogEntryParam(id: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getOperationLogEntryParam(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getOperationLogEntryResponse(id: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getOperationLogEntryResponse(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getPermissionErrors(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getPermissionErrors(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getPojoUser(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getPojoUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [sdate] 
     * @param {number} [edate] 
     * @param {Array<UserInfo>} [userInfo] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getRadiusLocations(sdate?: number, edate?: number, userInfo?: Array<UserInfo>, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getRadiusLocations(sdate, edate, userInfo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [userid] 
     * @param {number} [sdate] 
     * @param {number} [edate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getRetailStaffShifts(userid?: number, sdate?: number, edate?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getRetailStaffShifts(userid, sdate, edate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getStatusForUserName(userName: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getStatusForUserName(userName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [storeids] 
     * @param {number} [sdate] 
     * @param {number} [edate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getStoreShiftPeriods(storeids?: string, sdate?: number, edate?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getStoreShiftPeriods(storeids, sdate, edate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [storeid] 
     * @param {number} [sdate] 
     * @param {number} [edate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getStoreShifts(storeid?: number, sdate?: number, edate?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getStoreShifts(storeid, sdate, edate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getUserApps(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getUserApps(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} groupid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getUserAssociation(groupid: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getUserAssociation(groupid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} userid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getUserAssociationGroups(userid: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getUserAssociationGroups(userid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} userid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getUserGroups(userid: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getUserGroups(userid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [appID] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getUserGroupsByApp(appID?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getUserGroupsByApp(appID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getUserGroupsForUser(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getUserGroupsForUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Array<number>} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getUserInfo(requestBody?: Array<number>, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getUserInfo(requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} userid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getUserMethods(userid: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getUserMethods(userid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} userid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getUserParent(userid: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getUserParent(userid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} userid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getUserTree(userid: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getUserTree(userid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {StringList} [stringList] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getUserUserGroups(stringList?: StringList, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getUserUserGroups(stringList, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getUsernamesAndIds(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getUsernamesAndIds(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} groupid 
     * @param {Array<string>} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getUsersByGroups(groupid: number, requestBody?: Array<string>, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getUsersByGroups(groupid, requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} groupid 
     * @param {number} [companyid] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getUsersForGroup(groupid: number, companyid?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getUsersForGroup(groupid, companyid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} businessGroupId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getUserslist(businessGroupId: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getUserslist(businessGroupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [userGroups] 
     * @param {AccessRequest} [accessRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public giveRequestAccess(userGroups?: number, accessRequest?: AccessRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).giveRequestAccess(userGroups, accessRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listBusinessGroups(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listBusinessGroups(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listMethods(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listMethods(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listMyUsers(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listMyUsers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listMyUsers1(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listMyUsers1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listUsers(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listUsers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public login(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).login(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} userid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public logoff(userid: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).logoff(userid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} userid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public logon(userid: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).logon(userid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public remove(id: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).remove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} methodid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public remove1(methodid: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).remove1(methodid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Users} [users] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public remove2(users?: Users, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).remove2(users, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [retailstaffshiftid] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public removeRetailStaffShift(retailstaffshiftid?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).removeRetailStaffShift(retailstaffshiftid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [storeshiftid] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public removeStoreShift(storeshiftid?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).removeStoreShift(storeshiftid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [emailAddress] 
     * @param {string} [cellNumber] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public reset(emailAddress?: string, cellNumber?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).reset(emailAddress, cellNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Users} [users] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public resetPassword(users?: Users, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).resetPassword(users, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [username] 
     * @param {string} [contactnumber] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public searchForUsers(username?: string, contactnumber?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).searchForUsers(username, contactnumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [userid] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public searchResultsTree(userid?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).searchResultsTree(userid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [substring] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public searchUsersSubstring(substring?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).searchUsersSubstring(substring, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {BulkSMS} [bulkSMS] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public sendBulkSMS(bulkSMS?: BulkSMS, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).sendBulkSMS(bulkSMS, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {WhatsappIncommingObj} [whatsappIncommingObj] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public sendWhatappTextMessage(whatsappIncommingObj?: WhatsappIncommingObj, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).sendWhatappTextMessage(whatsappIncommingObj, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ChangePasswordRequest} [changePasswordRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public setPasswordForUsername(changePasswordRequest?: ChangePasswordRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).setPasswordForUsername(changePasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} userid 
     * @param {UserGroupIdList} [userGroupIdList] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public setUserAssociationGroups(userid: number, userGroupIdList?: UserGroupIdList, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).setUserAssociationGroups(userid, userGroupIdList, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} userid 
     * @param {UserIdList} [userIdList] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public setUsersSubUsers(userid: number, userIdList?: UserIdList, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).setUsersSubUsers(userid, userIdList, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} userId 
     * @param {number} subscribeBoolean 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public subscribeNetClockNotification(userId: number, subscribeBoolean: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).subscribeNetClockNotification(userId, subscribeBoolean, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public timeTypeSelection(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).timeTypeSelection(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Clock} [clock] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateTimesheetEntry(clock?: Clock, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateTimesheetEntry(clock, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} settingid 
     * @param {UserSetting} [userSetting] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateUserSetting(settingid: number, userSetting?: UserSetting, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateUserSetting(settingid, userSetting, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} groupName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userHasGroup(groupName: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).userHasGroup(groupName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [id] 
     * @param {number} [timestamp] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userTimestampData(id?: number, timestamp?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).userTimestampData(id, timestamp, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [hubMode] 
     * @param {number} [hubChallenge] 
     * @param {string} [hubVerifyToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public verificationRequest(hubMode?: string, hubChallenge?: number, hubVerifyToken?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).verificationRequest(hubMode, hubChallenge, hubVerifyToken, options).then((request) => request(this.axios, this.basePath));
    }
}


